//*******************************************************************
//Author: Cory Mckiel
//Date Created: Feb 20, 2020
//Last Modified: Feb 23, 2020
//Program Name: oss
//Associated Files: oss.c prime.c
//Compiler: gcc
//Options:  -h      (Displays a usage message)
//          -n x    (Indicate the maximum total of child processes,
//                      x, oss will ever create. Default 4)
//          -s x    (Indicate the number of children, x, allowed to
//                      exist in the system at the same time. Default 2)
//          -b B    (Start of the sequence of numbers to be tested
//                      for primality. Default 43)
//          -i I    (Increment between numbers that we test. Default 1)
//          -o filename     (Output file. Default is no output file.)
//
//Program Description: oss is a controller program that solves
//the problem of determining if a number is prime by launching
//multiple child processes suited towards this task, prime.c. At
//any given time there are a fixed number of child processes within
//the system. There is also a total number of children that oss will
//ever create.
//*******************************************************************

#include <errno.h>
#include <getopt.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

//Prints the help message.
void help();

//Stores the name the program was called with.
char calling_name[200];

//Declare this as volatile so the compiler
//knows that it can be asynchronously changed.
//Declare as atomic so that nothing tries
//to change at the same time.
static volatile sig_atomic_t done_flag = 0;

//This handler is triggered either when
//ctrl-c is used or the process has used
//more than 2 seconds of CPU time.
//done_flag is set to one to tell process
//to exit gracefully.
static void setdoneflag(int signo) 
{
    done_flag = 1;
}

//Set up the interrupt to catch SIGPROF,
//which is generated by ITIMER_PROF when
//2 seconds have passed. Also catch
//SIGINT which is generated by ctrl-c.
//returns -1 on failure and sets errno.
static int setupinterrupt()
{
    struct sigaction act;
    act.sa_handler = setdoneflag;
    act.sa_flags = 0;
    return (sigemptyset(&act.sa_mask) || sigaction(SIGPROF, &act, NULL) || sigaction(SIGINT, &act, NULL));
}

//Set up the timer to generate SIGPROF
//after 2 seconds.
static int setupitimer() 
{
    struct itimerval value;
    value.it_interval.tv_sec = 2;
    value.it_interval.tv_usec = 0;
    value.it_value = value.it_interval;
    return (setitimer(ITIMER_PROF, &value, NULL));
}

int main(int argc, char *argv[]) 
{
    //Store the name of the executable to a global variable
    //for error reporting.
    strncpy(calling_name, argv[0], 200);

    //Set up the interrupt.
    if (setupinterrupt() == -1) {
        fprintf(stderr, "%s: Error: Failed to set up the interrupt.\n%s\n", calling_name, strerror(errno)); 
        exit(-1);
    }
    //Set up the timer.
    if (setupitimer() == -1) {
        fprintf(stderr, "%s: Error: Failed to set up the timer.\n%s\n", calling_name, strerror(errno)); 
        exit(-1);
    }
    
    //Initialize these to acceptable default values.
    //The values can be replaced by cmd ln args.
    int child_proc_alltime_max = 4;
    int child_proc_realtime_max = 2;
    int start_of_prime_sequence = 43;
    int increment_sequence_by = 1;
    char output_file_name[200];
    int use_output_file = 0;

    //Set up for keeping track of children and
    //associated pids.
    //
    //Assign to each child a logical id used
    //to access it's space on the shared
    //memory array.
    int logical_id = 0;
    //The current total of lauched children.
    int child_proc_alltime_current = 0;
    //The current number of children in the
    //system right now.
    int child_proc_realtime_current = 0;
    //A pid for each child to help with termination.
    int pids[child_proc_alltime_max];
    //Initialize the pid's.
    int i;
    for (i = 0; i < child_proc_alltime_max; i++) {
        pids[i] = -1;
    }
 
    //Get all the command line arguments.  
    int option_index = 0;
    while ((option_index = getopt(argc, argv, "hn:s:b:i:o:")) != -1) {
        switch (option_index) {
            case 'h':
                help();
                exit(0);
                break;
            case 'n':
                if (atoi(optarg) <= 20 && atoi(optarg) >=0)
                    child_proc_alltime_max = atoi(optarg);
                break;
            case 's':
                if (atoi(optarg) <= 20 && atoi(optarg) >=0)
                    child_proc_realtime_max = atoi(optarg);
                break;
            case 'b':
                start_of_prime_sequence = atoi(optarg);
                break;
            case 'i':
                increment_sequence_by = atoi(optarg);
                break;
            case 'o':
                use_output_file = 1;
                strncpy(output_file_name, optarg, 200);
                break;
            default:
                fprintf(stderr, "Oops\n");
                exit(-1);
        }
    }

    //These are used to exec the new process
    //and are set up for only testing right now.
    char start_prime_buf[20];
    char logical_id_buf[20];
    char size_shm_buf[20];
   
    //Shared memory variables.
    key_t key;
    int shm_id;
    int *shm_ptr;

    //Use ftok to deterministically generate key so that
    //child process may do the same to access shared memory.
    if((key  = ftok("./", 432)) == -1) {
        fprintf(stderr, "%s: Error: ftok() failed to get shm key.\n%s\n", calling_name, strerror(errno));
        exit(-1);
    }
    //Create the shared memory segment to include the 2 integers
    //seconds and milliseconds, as well as an integer for each child
    //process in alltime_max.
    if ((shm_id = shmget(key, (2+child_proc_alltime_max)*sizeof(int), IPC_CREAT|0666)) < 0) {
        fprintf(stderr, "%s: Error: Failed to allocate shared memory.\n%s\n", calling_name, strerror(errno));
        exit(-1);
    }
    //Attach the memory segment to shm_ptr. Seconds is accessed
    //by *shm_ptr, milliseconds is accessed by *(shm_ptr+1), etc.
    if ((shm_ptr = (int*)shmat(shm_id, NULL, 0)) < 0) {
        fprintf(stderr, "%s: Error: Failed to attach shared memory.\n%s\n", calling_name, strerror(errno));
        exit(-1);
    }

    //Shared memory is not set up.
    //Initialize to zero.
    for (i = 0; i < (2+child_proc_alltime_max); i++) {
        *(shm_ptr+i) = 0;
    }

    //Create an array to keep track of which children
    //have already completed. This array is the same
    //size as the array in shared memory used for 
    //returning calculation results. The index
    //is the same as the child's logical id. If no results
    //have been returned for a child,
    //already_finished_children[child_id] = 0;
    //else set to one to indicate that the child
    //has finished.
    int already_finished_children[child_proc_alltime_max];
    for (i = 0; i < child_proc_alltime_max; i++) {
        already_finished_children[i] = 0;
    }

    //This flag will be set to 1 when all children
    //have finished their calculations.
    int all_children_finished = 0;

    //Flag for not creating more chidren.
    int no_more_children = 0;

    //This is the main loop for the program's
    //functionality.
    while (!all_children_finished) {

        //This for loop launches a number of children up to
        //the system's max specified by -s which can at most be 20.
        //as it creates children and children finish, child_proc_realtime_current
        //can be incremented or decremented to determine how many times
        //this loop runs.
        for (i = child_proc_realtime_current; i < child_proc_realtime_max; i++) {
            if (no_more_children) {
                //Don't create more children.
                break;
            }

            //Load the variables for execv into string form.    
            sprintf(start_prime_buf, "%d", start_of_prime_sequence);
            sprintf(logical_id_buf, "%d", logical_id);
            sprintf(size_shm_buf, "%d", (2+child_proc_alltime_max));

            //Fork and exec prime
            //Keep track of the pid in pids[].
            if ((pids[child_proc_alltime_current] = fork()) < 0) {
                fprintf(stderr, "%s: Error: fork() failed to launch child.\n%s\n", calling_name, strerror(errno));
                exit(-1);
            }
            else if (pids[child_proc_alltime_current] == 0) {
                //exec prime.
                char *exec_args[] = {"./prime", logical_id_buf, start_prime_buf, size_shm_buf, NULL};
                if (execv(exec_args[0], exec_args) == -1) {
                    fprintf(stderr, "%s: Error: execv() failed to execute new process.\n%s\n", calling_name, strerror(errno));
                    exit(-1);
                }
            }
            //Increment these variables to keep track
            //of how many children are in the system now,
            //how many total have been created, their logical
            //id's and the next prime to feed the next child.
            child_proc_realtime_current += 1;
            child_proc_alltime_current += 1;
            logical_id += 1;
            start_of_prime_sequence += increment_sequence_by;
        }

        //Increase the simulated clock.
        if ((*(shm_ptr+1) += 10000) == 1000000000) {
            *shm_ptr += 1;
            *(shm_ptr+1) = 0;
        }

        //Always check for the signal to terminate.
        if (done_flag) {
            break;
        }

        //Mechanism for detecting child finishing
        //and decreasing child_proc_realtime_current
        //so that new children can be created. Loop
        //through the shared memory. Add 2 to 
        //shm_ptr to ignore seconds and milliseconds.
        int k;
        for (k = 0; k < child_proc_alltime_max; k++) {
            //If the slot for the child's return value
            //in shared memory is non zero(it finished)
            //and if the child has never been observed
            //to have finished already.
            if (*(shm_ptr+(k+2)) != 0 && already_finished_children[k] == 0) {
                //Note it as finished.
                already_finished_children[k] = 1;
                //Create room for another child to exist.
                child_proc_realtime_current -= 1;
            }
        }

        //Mechanism for stopping the main while loop.
        //Loop through the entire array of finished 
        //children. If any have not finished yet,
        //break. If all have been observed as finished,
        //set the all_children_finished flag to end the
        //loop.
        for (k = 0; k < child_proc_alltime_max; k++) {
            if (already_finished_children[k] == 0) {
                break;
            }
            
            if (k == (child_proc_alltime_max-1)) {
                printf("All children finished\n");
                all_children_finished = 1;
            }
        }
        
        //If we have created the max amount of children,
        //set the no child flag.
        if (child_proc_alltime_current == child_proc_alltime_max - 0) {
            no_more_children = 1;
        }
    }           

    //Start to terminate children.
    int j;
    for (j = 0; j < child_proc_alltime_max; j++) {
        if (pids[j] > 0) {
            kill(pids[j], SIGUSR1);
        }
    }
   
    //Wait on the children. 
    while(wait(NULL) > 0);

    //Print their values to confirm.
    printf("%s: Seconds are: %d\n", calling_name, *shm_ptr);
    printf("%s: Milli are: %d\n", calling_name, *(shm_ptr+1));


    //Detach and remove shared memory segment.
    shmdt(shm_ptr);
    shmctl(shm_id, IPC_RMID, 0);

    return 0;
}

void help()
{
    printf("help\n");
}
