//*******************************************************************
//Author: Cory Mckiel
//Date Created: Feb 20, 2020
//Last Modified: Feb 23, 2020
//Program Name: oss
//Associated Files: oss.c prime.c
//Compiler: gcc
//Options:  -h      (Displays a usage message)
//          -n x    (Indicate the maximum total of child processes,
//                      x, oss will ever create. Default 4)
//          -s x    (Indicate the number of children, x, allowed to
//                      exist in the system at the same time. Default 2)
//          -b B    (Start of the sequence of numbers to be tested
//                      for primality. Default 43)
//          -i I    (Increment between numbers that we test. Default 1)
//          -o filename     (Output file. Default is no output file.)
//
//Program Description: oss is a controller program that solves
//the problem of determining if a number is prime by launching
//multiple child processes suited towards this task, prime.c. At
//any given time there are a fixed number of child processes within
//the system. There is also a total number of children that oss will
//ever create.
//*******************************************************************

#include <errno.h>
#include <getopt.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

//Prints the help message.
void help();

//Stores the name the program was called with.
char calling_name[200];

//Declare this as volatile so the compiler
//knows that it can be asynchronously changed.
//Declare as atomic so that nothing tries
//to change at the same time.
static volatile sig_atomic_t done_flag = 0;

//This handler is triggered either when
//ctrl-c is used or the process has used
//more than 2 seconds of CPU time.
//done_flag is set to one to tell process
//to exit gracefully.
static void setdoneflag(int signo) 
{
    done_flag = 1;
}

//Set up the interrupt to catch SIGPROF,
//which is generated by ITIMER_PROF when
//2 seconds have passed. Also catch
//SIGINT which is generated by ctrl-c.
//returns -1 on failure and sets errno.
static int setupinterrupt()
{
    struct sigaction act;
    act.sa_handler = setdoneflag;
    act.sa_flags = 0;
    return (sigemptyset(&act.sa_mask) || sigaction(SIGPROF, &act, NULL) || sigaction(SIGINT, &act, NULL));
}

//Set up the timer to generate SIGPROF
//after 2 seconds.
static int setupitimer() 
{
    struct itimerval value;
    value.it_interval.tv_sec = 2;
    value.it_interval.tv_usec = 0;
    value.it_value = value.it_interval;
    return (setitimer(ITIMER_PROF, &value, NULL));
}

int main(int argc, char *argv[]) 
{
    //Store the name of the executable to a global variable
    //for error reporting.
    strncpy(calling_name, argv[0], 200);

    //Set up the interrupt.
    if (setupinterrupt() == -1) {
        fprintf(stderr, "%s: Error: Failed to set up the interrupt.\n%s\n", calling_name, strerror(errno)); 
        exit(-1);
    }
    //Set up the timer.
    if (setupitimer() == -1) {
        fprintf(stderr, "%s: Error: Failed to set up the timer.\n%s\n", calling_name, strerror(errno)); 
        exit(-1);
    }
    
    //Initialize these to acceptable default values.
    int child_proc_alltime_max = 4;
    int child_proc_realtime_max = 2;
    int start_of_prime_sequence = 43;
    int increment_sequence_by = 1;
    char output_file_name[200];
    int use_output_file = 0;
 
    //Get all the command line arguments.  
    int option_index = 0;
    while ((option_index = getopt(argc, argv, "hn:s:b:i:o:")) != -1) {
        switch (option_index) {
            case 'h':
                help();
                exit(0);
                break;
            case 'n':
                if (atoi(optarg) <= 20 && atoi(optarg) >=0)
                    child_proc_alltime_max = atoi(optarg);
                break;
            case 's':
                if (atoi(optarg) <= 20 && atoi(optarg) >=0)
                    child_proc_realtime_max = atoi(optarg);
                break;
            case 'b':
                start_of_prime_sequence = atoi(optarg);
                break;
            case 'i':
                increment_sequence_by = atoi(optarg);
                break;
            case 'o':
                use_output_file = 1;
                strncpy(output_file_name, optarg, 200);
                break;
            default:
                fprintf(stderr, "Oops\n");
                exit(-1);
        }
    }

    //These are used to exec the new process
    //and are set up for only testing right now.
    int int_logical_id = 1;
    char start_prime_str[20];
    char logical_id[20];
    char size_shm[20];
    sprintf(start_prime_str, "%d", start_of_prime_sequence);
    sprintf(logical_id, "%d", int_logical_id);
    sprintf(size_shm, "%d", (2+child_proc_alltime_max));

    /* Test print for option detection
    printf("total child proc: %d\n", child_proc_alltime_max);
    printf("sys child proc: %d\n", child_proc_realtime_max);
    printf("start prime: %d\n", start_of_prime_sequence);
    printf("increment by: %d\n", increment_sequence_by);
    if (use_output_file) {
        printf("out file: %s\n", output_file_name);
    }
    */

    //Shared memory variables.
    key_t key;
    int shm_id;
    int *shm_ptr;

    //Use ftok to deterministically generate key so that
    //child process may do the same to access shared memory.
    if((key  = ftok("./", 432)) == -1) {
        fprintf(stderr, "%s: Error: ftok() failed to get shm key.\n%s\n", calling_name, strerror(errno));
        exit(-1);
    }
    //Create the shared memory segment to include the 2 integers
    //seconds and milliseconds, as well as an integer for each child
    //process in alltime_max.
    if ((shm_id = shmget(key, (2+child_proc_alltime_max)*sizeof(int), IPC_CREAT|0666)) < 0) {
        fprintf(stderr, "%s: Error: Failed to allocate shared memory.\n%s\n", calling_name, strerror(errno));
        exit(-1);
    }
    //Attach the memory segment to shm_ptr. Seconds is accessed
    //by *shm_ptr, milliseconds is accessed by *(shm_ptr+1), etc.
    if ((shm_ptr = (int*)shmat(shm_id, NULL, 0)) < 0) {
        fprintf(stderr, "%s: Error: Failed to attach shared memory.\n%s\n", calling_name, strerror(errno));
        exit(-1);
    }

    //Assign seconds and milliseconds as a test.
    *shm_ptr = 10;
    *(shm_ptr+1) = 20;


    //Fork and exec prime
    int pid;
    if ((pid = fork()) < 0) {
        fprintf(stderr, "%s: Error: fork() failed to launch child.\n%s\n", calling_name, strerror(errno));
        exit(-1);
    }
    else if (pid == 0) {
        char *exec_args[] = {"./prime", logical_id, start_prime_str, size_shm, NULL};
        if (execv(exec_args[0], exec_args) == -1) {
            fprintf(stderr, "%s: Error: execv() failed to execute new process.\n%s\n", calling_name, strerror(errno));
            exit(-1);
        }
    }

    //Go into an infinite loop to test timer interrupt.
    while (!done_flag);

    //If past the loop, tell the child to terminate using
    //SIGUSR1
    kill(pid, SIGUSR1);
   
    //Wait on the child. 
    //printf("%s: Waiting on child...\n", calling_name);
    wait(NULL);

    //Print their values to confirm.
    printf("%s: Seconds are: %d\n", calling_name, *shm_ptr);
    printf("%s: Milli are: %d\n", calling_name, *(shm_ptr+1));


    //Detach and remove shared memory segment.
    shmdt(shm_ptr);
    shmctl(shm_id, IPC_RMID, 0);
    

    return 0;
}

void help()
{
    printf("help\n");
}
